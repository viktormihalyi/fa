<!DOCTYPE html>
<html>

<head>
    <title>3D Grafikus Rendszerek</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="css/style.css" />
</head>

<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="overlay"></div>
    </div>

    <script src="js/WebGLMath/Mat4.js"></script>
    <script src="js/WebGLMath/Vec1.js"></script>
    <script src="js/WebGLMath/Vec2.js"></script>
    <script src="js/WebGLMath/Vec3.js"></script>
    <script src="js/WebGLMath/Vec4.js"></script>
    <script src="js/WebGLMath/VecArray.js"></script>
    <script src="js/WebGLMath/Vec1Array.js"></script>
    <script src="js/WebGLMath/Vec2Array.js"></script>
    <script src="js/WebGLMath/Vec3Array.js"></script>
    <script src="js/WebGLMath/Vec4Array.js"></script>
    <script src="js/WebGLMath/Mat4Array.js"></script>
    <script src="js/WebGLMath/Sampler2D.js"></script>
    <script src="js/WebGLMath/SamplerCube.js"></script>
    <script src="js/WebGLMath/UniformReflection.js"></script>

    <script src=//cdnjs.cloudflare.com/ajax/libs/seedrandom/2.3.10/seedrandom.min.js></script>

    <script>
        Math.seedrandom(7);

        function randomBetween(min, max) {
            return Math.floor(Math.random()*(max-min+1)+min);
        }

        const canvas = document.getElementById("canvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const ctx = canvas.getContext("2d");

        let attractionPoints = [];
        const ATTRACTION_POINT_COUNT = 500;

        const CIRCLE_CENTER = new Vec2(canvas.width/2, canvas.height/4);
        const CIRCLE_RADIUS = 200;

        const INFL_MIN_DIST = 15;
        const INFL_MAX_DIST = 50;

        const BRANCH_LENGTH = 5;
        const TREE_START_POS = new Vec2(canvas.width/2, canvas.height);
        const INITIAL_DIRECTION = new Vec2(0, -1);

        function good_point(pos) {
            return pos.minus(CIRCLE_CENTER).length() < CIRCLE_RADIUS;
        }

        while (attractionPoints.length < ATTRACTION_POINT_COUNT) {
            const rndpoint = new Vec2(
                randomBetween(0, canvas.width),
                randomBetween(0, canvas.height));

            if (good_point(rndpoint)) {
                attractionPoints.push(rndpoint);
            }
        }


        class TreeNode {
            constructor(parent, pos, dir, width) {
                this.parent = parent;
                this.pos = pos;
                this.dir = dir.clone().normalize();
                this.width = width;
            }
        }

        const tree = [];
        tree.push(new TreeNode(null, TREE_START_POS, INITIAL_DIRECTION, 10));


        function updateAndRender() {
            console.log(tree.length);
            if (attractionPoints.length === 0 || tree.length > 1500) {
                return;
            }

            let influencedNodes = tree.map(node => ({node: node, attrs: []}));

            // find closest node to each attraction point
            let found = false;
            for (let apoint of attractionPoints) {

                let closest = null;
                let closestDist = Number.MAX_SAFE_INTEGER;
                for (let treeNode of tree) {
                    let dist = treeNode.pos.minus(apoint).length();
                    if (dist < closestDist && INFL_MIN_DIST < dist && dist < INFL_MAX_DIST) {
                        closest = treeNode;
                        closestDist = dist;
                    }
                }

                if (closest !== null) {
                    found = true;
                    let t = influencedNodes.find((n) => n.node === closest);
                    t.attrs.push(apoint);
                }
            }

            // grow tree
            if (!found) {
                // no attraction at all, just grow up
                const lastNode = tree[tree.length-1];
                tree.push(new TreeNode(lastNode, lastNode.pos.plus(lastNode.dir.times(BRANCH_LENGTH)), lastNode.dir, lastNode.width*0.98));

            } else {
                // grow according to attractions
                for (let inflNode of influencedNodes) {

                    // ignore those tree nodes that have no attraction
                    if (inflNode.attrs.length === 0) {
                        continue;
                    }

                    // attraction points whose closest node is the current one
                    let attrs = influencedNodes.find((n) => n.node === inflNode.node).attrs;

                    // sum up all attrpoint-node directions
                    let sumVect = new Vec2(0, 0);
                    for (let apoint of attrs) {
                        sumVect.add(apoint.minus(inflNode.node.pos));
                    }
                    sumVect.normalize();
                    // also include the previous direction
                    sumVect.add(inflNode.node.dir.times(1.2));
                    sumVect.normalize();
                    sumVect.mul(BRANCH_LENGTH);

                    // add node
                    tree.push(new TreeNode(inflNode.node, inflNode.node.pos.plus(sumVect), sumVect, inflNode.node.width*0.98));
                }
            }

            // remove consumed points
            attractionPoints = attractionPoints.filter((e) => {
                let closestDist = Number.MAX_SAFE_INTEGER;
                for (let treeNode of tree) {
                    let dist = treeNode.pos.minus(e).length();
                    if (dist < closestDist) {
                        closestDist = dist;
                    }
                }
                return closestDist >= INFL_MIN_DIST;
            });

            // clear screen
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // draw tree
            for (let n of tree) {
                // let n = tree[tree.length-1];
                if (n.parent !== null) {
                    ctx.fillStyle = "#FF0000";
                    ctx.lineWidth = n.width;
                    ctx.beginPath();
                    ctx.moveTo(n.pos.x, n.pos.y);
                    ctx.lineTo(n.parent.pos.x, n.parent.pos.y);
                    ctx.stroke();
                }
            }

            // draw attraction points
            for (let point of attractionPoints) {
                ctx.fillStyle = "#0000FF44";
                ctx.fillRect(point.x-2, point.y-2, 4, 4);
            }

            setTimeout(updateAndRender, 1);
        }
        updateAndRender();

    </script>
</body>

</html>