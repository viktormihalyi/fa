<!DOCTYPE html>
<html>

<head>
    <title>3D Grafikus Rendszerek</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="css/style.css" />
</head>

<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="overlay"></div>
    </div>

    <script src="js/WebGLMath/Mat4.js"></script>
    <script src="js/WebGLMath/Vec1.js"></script>
    <script src="js/WebGLMath/Vec2.js"></script>
    <script src="js/WebGLMath/Vec3.js"></script>
    <script src="js/WebGLMath/Vec4.js"></script>
    <script src="js/WebGLMath/VecArray.js"></script>
    <script src="js/WebGLMath/Vec1Array.js"></script>
    <script src="js/WebGLMath/Vec2Array.js"></script>
    <script src="js/WebGLMath/Vec3Array.js"></script>
    <script src="js/WebGLMath/Vec4Array.js"></script>
    <script src="js/WebGLMath/Mat4Array.js"></script>
    <script src="js/WebGLMath/Sampler2D.js"></script>
    <script src="js/WebGLMath/SamplerCube.js"></script>
    <script src="js/WebGLMath/UniformReflection.js"></script>

    <script src=//cdnjs.cloudflare.com/ajax/libs/seedrandom/2.3.10/seedrandom.min.js></script>

    <script src="js/App.js"></script>
    <script src="js/keycodes.js"></script>
    <script src="js/Program.js"></script>
    <script src="js/QuadGeometry.js"></script>
    <script src="js/LinesGeometry.js"></script>
    <script src="js/Scene.js"></script>
    <script src="js/Camera.js"></script>
    <script src="js/Tree.js"></script>
    <script src="js/Shader.js"></script>
    <script src="js/Texture2D.js"></script>
    <script src="js/shaders/idle_vs.essl"></script>
    <script src="js/shaders/solid_fs.essl"></script>


    <script>

        // Math.seedrandom(7);

        // function randomBetween(min, max) {
        //     return Math.floor(Math.random()*(max-min+1)+min);
        // }

        // const canvas = document.getElementById("canvas");
        // canvas.width = window.innerWidth;
        // canvas.height = window.innerHeight;
        // const ctx = canvas.getContext("2d");

        // const ATTRACTION_POINT_COUNT = 500;

        // const CIRCLE_CENTER = new Vec3(canvas.width/2, canvas.height/4, 0);
        // const CIRCLE_RADIUS = 200;

        // const INFL_MIN_DIST = 15;
        // const INFL_MAX_DIST = 50;

        // const BRANCH_LENGTH = 5;
        // const TREE_START_POS = new Vec3(canvas.width/2, canvas.height, 0);
        // const INITIAL_DIRECTION = new Vec3(0, -1, 0);

        // let tree = [];
        // let attractionPoints = [];

        // class TreeNode {
        //     constructor(parent, pos, dir, width) {
        //         this.parent = parent;
        //         this.pos = pos;
        //         this.dir = dir.clone().normalize();
        //         this.width = width;
        //     }
        // }

        // function good_point(pos) {
        //     return pos.minus(CIRCLE_CENTER).length() < CIRCLE_RADIUS;
        // }

        // function setup() {
        //     while (attractionPoints.length < ATTRACTION_POINT_COUNT) {
        //         const rndpoint = new Vec3(
        //             randomBetween(0, canvas.width),
        //             randomBetween(0, canvas.height), 1);

        //         if (good_point(rndpoint)) {
        //             attractionPoints.push(rndpoint);
        //         }
        //     }

        //     tree.push(new TreeNode(null, TREE_START_POS, INITIAL_DIRECTION, 10));
        // }

        // function drawLine(from, to) {
        //     ctx.beginPath();
        //     ctx.moveTo(from.x, from.y);
        //     ctx.lineTo(to.x, to.y);
        //     ctx.stroke();
        // }

        // function render() {
        //     ctx.clearRect(0, 0, canvas.width, canvas.height);

        //     // draw tree
        //     for (let n of tree) {
        //         // let n = tree[tree.length-1];
        //         if (n.parent !== null) {
        //             ctx.fillStyle = "#FF0000";
        //             ctx.lineWidth = n.width;
        //             drawLine(n.pos, n.parent.pos);
        //         }
        //     }

        //     // draw attraction points
        //     for (let point of attractionPoints) {
        //         ctx.fillStyle = "#0000FF44";
        //         ctx.fillRect(point.x-2, point.y-2, 4, 4);
        //     }
        // }

        // function removeReachedAttractionPoints() {
        //     attractionPoints = attractionPoints.filter((e) => {
        //         let closestDist = Number.MAX_SAFE_INTEGER;
        //         for (let treeNode of tree) {
        //             let dist = treeNode.pos.minus(e).length();
        //             if (dist < closestDist) {
        //                 closestDist = dist;
        //             }
        //         }
        //         return closestDist >= INFL_MIN_DIST;
        //     });
        // }

        // function updateAndRender() {
        //     if (attractionPoints.length === 0 || tree.length > 1500) {
        //         return;
        //     }

        //     let influencedNodes = tree.map(node => ({node: node, attrs: []}));

        //     // find closest node to each attraction point
        //     let found = false;
        //     for (let apoint of attractionPoints) {

        //         let closest = null;
        //         let closestDist = Number.MAX_SAFE_INTEGER;
        //         for (let treeNode of tree) {
        //             let dist = treeNode.pos.minus(apoint).length();
        //             if (dist < closestDist && INFL_MIN_DIST < dist && dist < INFL_MAX_DIST) {
        //                 closest = treeNode;
        //                 closestDist = dist;
        //             }
        //         }

        //         if (closest !== null) {
        //             found = true;
        //             let t = influencedNodes.find((n) => n.node === closest);
        //             t.attrs.push(apoint);
        //         }
        //     }

        //     // grow tree
        //     if (!found) {
        //         // no attraction at all, just grow up
        //         const lastNode = tree[tree.length-1];
        //         tree.push(new TreeNode(lastNode, lastNode.pos.plus(lastNode.dir.times(BRANCH_LENGTH)), lastNode.dir, lastNode.width*0.98));

        //     } else {
        //         // grow according to attractions
        //         for (let inflNode of influencedNodes) {

        //             // ignore those tree nodes that have no attraction
        //             if (inflNode.attrs.length === 0) {
        //                 continue;
        //             }

        //             // attraction points whose closest node is the current one
        //             let attrs = influencedNodes.find((n) => n.node === inflNode.node).attrs;

        //             // sum up all attrpoint-node directions
        //             let sumVect = new Vec3(0, 0, 0);
        //             for (let apoint of attrs) {
        //                 sumVect.add(apoint.minus(inflNode.node.pos));
        //             }
        //             sumVect.normalize();
        //             // also include the previous direction
        //             sumVect.add(inflNode.node.dir.times(1.2));
        //             sumVect.normalize();
        //             sumVect.mul(BRANCH_LENGTH);

        //             // add node
        //             tree.push(new TreeNode(inflNode.node, inflNode.node.pos.plus(sumVect), sumVect, inflNode.node.width*0.98));
        //         }
        //     }

        //     // remove consumed points
        //     removeReachedAttractionPoints();

        //     // clear screen
        //     // render();

        //     setTimeout(updateAndRender, 1);
        // }

        // setup();
        // updateAndRender();

    </script>

</body>

</html>